# Dynamic Programming no.3
# 효율적인 화폐 구성

# N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치가의 합이 M원이 되도록 하려고 한다.
# 이때 각 종류의 화폐는 몇 개라도 사용할 수 있다.
# 예를들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.
# M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하라.

# 문제해결 아이디어
# ai = 금액 i를 만들 수 있는 최소한의 화폐 개수
# k = 각 화폐의 단위
# 점화식 : 각 화폐 단위인 k를 하나씩 확인하며
# ai-k를 만드는 방법이 존재하는 경우, ai = min(ai, ai-k + 1)
# ai-k를 만드는 방법이 존재하지 않을 경우, ai = INF

# 예시
# N = 3, M = 7이고, 각 화폐의 단위가 2, 3, 5인 경우 확인
# Step 0 - 초기화
# 먼저 각 인덱스에 해당하는 값으로 INF(무한)의 값을 설정한다.
# INF은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미를 가진다.
# 본 문재에서는 10,001을 사용할 수 있다.

# 인덱스   0   1   2   3   4   5   6   7
# 값      0   INF INF INF INF INF INF INF

# Step 1
# 첫 번째 화폐 단위인 2를 확인한다.
# 점화식에 따라 리스트가 갱신된다.

# 인덱스   0   1   2   3   4   5   6   7
# 값      0  INF  1  INF  2   INF 3   INF

# Step 2
# 두 번째 화폐 단위인 3을 확인한다.
# 점화식에 따라 리스트가 갱신된다.

# 인덱스   0   1   2   3   4   5   6   7
# 값      0  INF  1   1   2   2   3   3 -> 2원 + 2원 + 3원 - 3회

# Step 3
# 두 번째 화폐 단위인 5을 확인한다.
# 점화식에 따라 리스트가 갱신된다.

# 인덱스   0   1   2   3   4   5   6   7
# 값      0  INF  1   1   2   1   3   2 -> 2원 5원 - 2회

import sys
# 정수 N, M 입력
n, m = map(int, sys.stdin.readline().split())

# N개의 화폐 단위 정보를 입력받기
money = list(map(int, sys.stdin.readline().split()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (m + 1)

# 바텀업
d[0] = 0
for i in range(n):
    for j in range(money[i], m + 1): # 현재의 화폐에서 m 원까지 만들수 있다면
        if d[j - money[i]] != 10001: # (i - k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[j - money[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001: # 최종적으로 m 원을 만드는 방법이 없는 경우
    print(1)
else:
    print(d[m])
