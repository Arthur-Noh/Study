# Dynamic Programming no.5
# 병사 배치하기 문제

# N명의 병사가 무작위로 나열되어 있다.
# 각 병사는 특정한 값의 전투력을 보유하고 있다.
# 병사를 배치할 때는 전투력이 높은 병사가 앞쪽에 오도록 내림차순 배치를 하고자 한다.
# 앞쪽에 있는 병사의 전투력이 항상 뒤쪽에 있는 병사보다 높아야 한다.
# 배치 과정에서 특정한 위치에 있는 병사를 열외시키는 방법을 이용한다.
# 그러면서 남아있는 병사의 수가 최대가 되도록하고 싶다.

# 예를 들어, N = 7 일때 나열된 병사의 전투력은 다음과 같다고 가정한다.
#   1   2   3   4   5   6   7
#   15  11  4   8   5   2   4

# 이때 3번과 6번을 열외시키면 내림차순이 형태가 되어 5명이 된다.
# 이는 남아있는 병사의 수가 최대가 되게 하는 방법이다.
#   1   2   4   5   7
#   15  11  8   5   4

# 병사에 대한 정보가 주어졌을 때, 남아있는 병사의 수가 최대가 되도록 하기 위한 열외시켜야 하는 병사의 수를 출력하는 프로그램을 작성하라

# 문제해결 아이디어
# 가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS)로 전형적인 다이나믹 프로그래밍이다.
# 예를들어 수열 array = {4, 2, 5, 8, 4, 11, 15}가 있다고 가정하고
# 이 수열의 가장 긴 증가하는 부분 수열은 {4, 5, 8, 11, 15} 이다.
# 본 문제는 가장 긴 감소하는 부분 수열을 찾는 문제로 치환할 수 있으므로 LIS 알고리즘을 수정, 적용하면 정답을 찾을 수 있다.

# d[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
# 점화식
# 모든 0 <= j < i 에 대하여, d[i] = max(d[i], d[j] + 1) if array[j] < array[i]

import sys
n = int(sys.stdin.readline().rstrip())
array = list(map(int, sys.stdin.readline().split()))

# 순서를 뒤집어 '최장 증가 부분 수열' 문제로 변환
array.reverse()

# 다이나믹 프로그래밍을 위한 1차원 DP 테이블 초기화
dp = [1] * n

# 가장 긴 증가하는 부분 수열(LIS) 알고리즘 수행
for i in range(1, n):
    for j in range(0, i):
        if array[j] < array[i]:
            dp[i] = max(dp[i], dp[j] + 1)

# 열외해야하는 병사의 최소 수를 출력
print(n - max(dp))
